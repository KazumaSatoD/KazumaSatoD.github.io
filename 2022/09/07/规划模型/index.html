<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>规划模型 | JiaHaoD博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="线性规划和非线性规划整理一、线性规划模型1.定义：目标函数和约束条件是待求变量的线性函数、线性等式或线性不等式的数学规划模型。它所描述的典型问题是怎样以最优的方式在各项活动中间分配有限资源的问题。 线性规划问题是在一组线性约束条件的限制下，求一线性目标函数最大或最小的问题。 2.一般形式2.1 线性规划模型解决问题的共同特征 ​      1.决策变量。一般决策变量非负 ​      2.约束条件">
<meta property="og:type" content="article">
<meta property="og:title" content="规划模型">
<meta property="og:url" content="http://example.com/2022/09/07/%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="JiaHaoD博客">
<meta property="og:description" content="线性规划和非线性规划整理一、线性规划模型1.定义：目标函数和约束条件是待求变量的线性函数、线性等式或线性不等式的数学规划模型。它所描述的典型问题是怎样以最优的方式在各项活动中间分配有限资源的问题。 线性规划问题是在一组线性约束条件的限制下，求一线性目标函数最大或最小的问题。 2.一般形式2.1 线性规划模型解决问题的共同特征 ​      1.决策变量。一般决策变量非负 ​      2.约束条件">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/huawei/AppData/Roaming/Typora/typora-user-images/image-20220801225231571.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-42780ed7f5d34671eebd8cc243ccf028_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-df9f635069c8fef678c05658d2921474_720w.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714151853438.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714152626504.png">
<meta property="og:image" content="c:/Users/huawei/AppData/Roaming/Typora/typora-user-images/image-20220803231702781.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210715104914558.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210715105316521.png">
<meta property="og:image" content="c:/Users/huawei/AppData/Roaming/Typora/typora-user-images/image-20220806215816855.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210217210139890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dheW5lNjUxNQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021053017280132.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530172825134.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210530172837714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTI4Mjgz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images0.cnblogs.com/blog/657755/201502/050225437813681.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/657755/201502/050225454533927.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/657755/201502/050225466715398.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/657755/201502/050225479215114.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/657755/201502/050225492653857.png">
<meta property="og:image" content="https://images0.cnblogs.com/blog/657755/201502/050226014535681.png">
<meta property="article:published_time" content="2022-09-07T13:25:36.000Z">
<meta property="article:modified_time" content="2022-09-07T13:26:16.867Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/huawei/AppData/Roaming/Typora/typora-user-images/image-20220801225231571.png">
  
    <link rel="alternate" href="/atom.xml" title="JiaHaoD博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JiaHaoD博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-规划模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/07/%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2022-09-07T13:25:36.000Z" itemprop="datePublished">2022-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      规划模型
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线性规划和非线性规划整理"><a href="#线性规划和非线性规划整理" class="headerlink" title="线性规划和非线性规划整理"></a>线性规划和非线性规划整理</h1><h2 id="一、线性规划模型"><a href="#一、线性规划模型" class="headerlink" title="一、线性规划模型"></a>一、线性规划模型</h2><h3 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h3><p>目标函数和约束条件是待求变量的线性函数、线性等式或线性不等式的数学规划模型。它所描述的典型问题是怎样以<strong>最优</strong>的方式在各项活动中间分配有限资源的问题。</p>
<p>线性规划问题是在一组线性约束条件的限制下，求一<strong>线性目标函数最大或最小</strong>的问题。</p>
<h3 id="2-一般形式"><a href="#2-一般形式" class="headerlink" title="2.一般形式"></a>2.一般形式</h3><p>2.1 线性规划模型解决问题的共同特征</p>
<p>​      1.决策变量。一般决策变量非负</p>
<p>​      2.约束条件，问题存在一定的限制条件</p>
<p>​      3.目标函数，存在一个目标要求，关于决策变量的线性函数的最大值或最小值</p>
<p>2.2线性规划matlab标准形式</p>
<p><img src="C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220801225231571.png" alt="image-20220801225231571"></p>
<h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3.步骤"></a>3.步骤</h3><p>*<strong>1.假设决策变量；*</strong></p>
<p>*<strong>2.建立目标函数；*</strong></p>
<p>*<strong>3.寻找约束条件。*</strong></p>
<h3 id="4-转化为线性规划问题"><a href="#4-转化为线性规划问题" class="headerlink" title="4. 转化为线性规划问题"></a>4. 转化为线性规划问题</h3><p>将非线性的目标函数转化为线性函数</p>
<p>方法 令x&#x3D;u-v；|x|&#x3D;u+v,使用u，v代替x。</p>
<h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h3><p>例一：某军工厂生产甲、乙、丙三种产品，生产三 种产品需要A、B两种资源，其单位需求量及利润由下表1给出，问每天生产甲、乙、丙三种产品各多少，可使总利润最大？</p>
<p>表1如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-42780ed7f5d34671eebd8cc243ccf028_720w.jpg" alt="img"></p>
<p>我们可以根据题目信息进行下面步骤求解：</p>
<blockquote>
<p><em><strong>第一步，假设决策变量！</strong></em></p>
</blockquote>
<p>假设每天生产甲、乙、丙三种产品各 x1 , x2 , x3 件可使总利润最大</p>
<blockquote>
<p><em><strong>第二步，建立目标函数</strong></em></p>
</blockquote>
<p>建立目标函数 maxz&#x3D;40x1+45x2+24x3</p>
<blockquote>
<p>*<strong>第三步，寻找约束条件*</strong></p>
</blockquote>
<p>寻找约束条件</p>
<p><img src="https://pic1.zhimg.com/80/v2-df9f635069c8fef678c05658d2921474_720w.jpg" alt="img"></p>
<h3 id="6-matlab代码整理"><a href="#6-matlab代码整理" class="headerlink" title="6.matlab代码整理"></a>6.matlab代码整理</h3><p><strong>[x,fval]&#x3D;linprog(f,A,b,Aeq,beq,lb,ub,x0,OPTIONS)</strong></p>
<p><strong>x</strong>返回决策向量的取值,即最优值；<br><strong>fval</strong>返回目标函数的最优值；<br><strong>A</strong>和<strong>b</strong>对应线性不等式约束；<br><strong>Aeq</strong>和<strong>beq</strong>对应线性等式约束；<br><strong>lb</strong>和<strong>ub</strong>分别对应决策向量的下界向量和上界向量；<br><strong>x0</strong>是<strong>x</strong>的初始值；<strong>OPTIONS</strong>是控制参数，为指定参数进行最小化；</p>
<p>例题：</p>
<p>例1：求解下列线性规划问题。<br><img src="https://img-blog.csdnimg.cn/20210714151853438.png" alt="在这里插入图片描述"><br><strong>解：（1）化成matlab标准型，即：</strong><br><img src="https://img-blog.csdnimg.cn/20210714152626504.png" alt="在这里插入图片描述"><br><strong>（2)求解的matlab程序如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f=[-2;-3;5];</span><br><span class="line">a=[-2,5,-1;1,3,1];</span><br><span class="line">b=[-10;12];</span><br><span class="line">aeq=[1,1,1];</span><br><span class="line">beq=7;</span><br><span class="line">[x,y]=linprog(f,a,b,aeq,beq,zeros(3,1));</span><br><span class="line">x</span><br><span class="line">y=-y</span><br></pre></td></tr></table></figure>



<h2 id="二、整数线性规划模型"><a href="#二、整数线性规划模型" class="headerlink" title="二、整数线性规划模型"></a>二、整数线性规划模型</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>在线性模型中，变量限制为整数，则称为整数线性规划</p>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><p>1、纯整数规划：所有决策变量均要求为整数的整数规划（松弛变量、剩余变量不要求）</p>
<p>2、全整数规划（包括松弛变量、剩余变量均要求为整数的整数规划）</p>
<p>3、混合整数规划：部分决策变量均要求为整数的整数规划</p>
<p>4、纯0－1整数规划：所有决策变量均要求为0－1的整数规划</p>
<p>5、混合0－1规划：部分决策变量均要求为0－1的整数规划</p>
<h3 id="3-一般形式"><a href="#3-一般形式" class="headerlink" title="3.一般形式"></a>3.一般形式</h3><p><img src="C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220803231702781.png" alt="image-20220803231702781"></p>
<h3 id="4-整数规划的求解"><a href="#4-整数规划的求解" class="headerlink" title="4.整数规划的求解"></a>4.整数规划的求解</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><h5 id="1-分支定界法"><a href="#1-分支定界法" class="headerlink" title="1.分支定界法"></a>1.分支定界法</h5><h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><p>1.先求出松弛问题的最优解（线性规划） </p>
<p>​    1.无解 </p>
<p>​    2.最优解为整数解（即得） </p>
<p>​    3.最优解不是整数 -&gt;构造新的约束条件</p>
<p> 2.任选一个 非整数解变量 x i , 在 松弛问题 中加上约束 :</p>
<p>x i ≤ [ x i ] 和 x i ≥ [ x i ] + 1 形成 两个新的松弛问题 , 就是两个分支</p>
<p>3.定界：对每个后续问题求解，过滤不必要的分支</p>
<p>4.重复2、3直到得到最优解</p>
<h6 id="matlab代码："><a href="#matlab代码：" class="headerlink" title="matlab代码："></a>matlab代码：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">主函数：</span><br><span class="line">% main.m</span><br><span class="line">% 分支定界法</span><br><span class="line">% -----------------------------------------------</span><br><span class="line">% 求解模型：</span><br><span class="line">% min z = f * x</span><br><span class="line">% A * x &lt;= b</span><br><span class="line">% x &gt;= 0,且为整数</span><br><span class="line">% ---------------------------------------------------</span><br><span class="line">clear global;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">global result; % 存储所有整数解</span><br><span class="line">global lowerBound; % 下界</span><br><span class="line">global upperBound; % 上界</span><br><span class="line">global count; % 用以判断是否为第一次分支</span><br><span class="line"></span><br><span class="line">count = 1;</span><br><span class="line"></span><br><span class="line">f = [-40, -90];</span><br><span class="line">A = [8, 7;</span><br><span class="line">    7, 20;];</span><br><span class="line">b = [56; 70];</span><br><span class="line">Aeq = [];</span><br><span class="line">beq = [];</span><br><span class="line">lbnd = [0; 0];</span><br><span class="line">ubnd = [inf; inf];</span><br><span class="line"></span><br><span class="line">BinTree = createBinTreeNode(&#123;f, A, b, Aeq, beq, lbnd, ubnd&#125;);</span><br><span class="line">if ~isempty(result)</span><br><span class="line">    [fval,flag]=min(result(:,end)); % result中每一行对应一个整数解及对应的函数值</span><br><span class="line">    Result=result(flag,:);</span><br><span class="line">    disp(&#x27;该整数规划问题的最优解为：&#x27;);</span><br><span class="line">    disp(Result(1,1:end-1));</span><br><span class="line">    disp(&#x27;该整数规划问题的最优值为：&#x27;);</span><br><span class="line">    disp(Result(1,end));</span><br><span class="line">else</span><br><span class="line">    disp(&#x27;该整数规划问题无可行解&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">% createBinTreeNode.m</span><br><span class="line">% 构建二叉树，每一结点对应一解</span><br><span class="line">function BinTree = createBinTreeNode(binTreeNode)</span><br><span class="line"></span><br><span class="line">global result;</span><br><span class="line">global lowerBound;</span><br><span class="line">global upperBound;</span><br><span class="line">global count;</span><br><span class="line"></span><br><span class="line">if isempty(binTreeNode)</span><br><span class="line">    return;</span><br><span class="line">else</span><br><span class="line">    BinTree&#123;1&#125; = binTreeNode;</span><br><span class="line">    BinTree&#123;2&#125; = [];</span><br><span class="line">    BinTree&#123;3&#125; = [];</span><br><span class="line">    </span><br><span class="line">    [x, fval, exitflag] = linprog(binTreeNode&#123;1&#125;, binTreeNode&#123;2&#125;, binTreeNode&#123;3&#125;, ...</span><br><span class="line">        binTreeNode&#123;4&#125;, binTreeNode&#123;5&#125;, binTreeNode&#123;6&#125;, binTreeNode&#123;7&#125;);</span><br><span class="line">    if count == 1</span><br><span class="line">%         upperBound = 0; % 初始下界为空</span><br><span class="line">        lowerBound = fval;</span><br><span class="line">        count = 2;</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    if ~IsInRange(fval)</span><br><span class="line">        return;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    if exitflag == 1</span><br><span class="line">        flag = [];</span><br><span class="line">        % 寻找非整数解分量</span><br><span class="line">        for i = 1 : length(x)</span><br><span class="line">            if round(x(i)) ~= x(i)</span><br><span class="line">                flag = i;</span><br><span class="line">                break;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        % 分支</span><br><span class="line">        if ~isempty(flag)</span><br><span class="line">            lowerBound = max([lowerBound; fval]);</span><br><span class="line">            OutputLowerAndUpperBounds();</span><br><span class="line">            lbnd = binTreeNode&#123;6&#125;;</span><br><span class="line">            ubnd = binTreeNode&#123;7&#125;;</span><br><span class="line">            lbnd(flag, 1) = ceil(x(flag, 1)); % 朝正无穷四舍五入</span><br><span class="line">            ubnd(flag, 1) = floor(x(flag, 1));</span><br><span class="line">            </span><br><span class="line">            % 进行比较，优先选择目标函数较大的进行分支</span><br><span class="line">            [~, fval1] = linprog(binTreeNode&#123;1&#125;, binTreeNode&#123;2&#125;, binTreeNode&#123;3&#125;, ...</span><br><span class="line">        binTreeNode&#123;4&#125;, binTreeNode&#123;5&#125;, binTreeNode&#123;6&#125;, ubnd);</span><br><span class="line">            [~, fval2] = linprog(binTreeNode&#123;1&#125;, binTreeNode&#123;2&#125;, binTreeNode&#123;3&#125;, ...</span><br><span class="line">        binTreeNode&#123;4&#125;, binTreeNode&#123;5&#125;, lbnd, binTreeNode&#123;7&#125;);</span><br><span class="line">            if fval1 &lt; fval2                </span><br><span class="line">                % 创建左子树          </span><br><span class="line">                BinTree&#123;2&#125; = createBinTreeNode(&#123;binTreeNode&#123;1&#125;, binTreeNode&#123;2&#125;, binTreeNode&#123;3&#125;, ...</span><br><span class="line">            binTreeNode&#123;4&#125;, binTreeNode&#123;5&#125;, binTreeNode&#123;6&#125;, ubnd&#125;);</span><br><span class="line"></span><br><span class="line">                % 创建右子树</span><br><span class="line">                BinTree&#123;3&#125; = createBinTreeNode(&#123;binTreeNode&#123;1&#125;, binTreeNode&#123;2&#125;, binTreeNode&#123;3&#125;, ...</span><br><span class="line">            binTreeNode&#123;4&#125;, binTreeNode&#123;5&#125;, lbnd, binTreeNode&#123;7&#125;&#125;);</span><br><span class="line">            else</span><br><span class="line">                % 创建右子树</span><br><span class="line">                BinTree&#123;3&#125; = createBinTreeNode(&#123;binTreeNode&#123;1&#125;, binTreeNode&#123;2&#125;, binTreeNode&#123;3&#125;, ...</span><br><span class="line">            binTreeNode&#123;4&#125;, binTreeNode&#123;5&#125;, lbnd, binTreeNode&#123;7&#125;&#125;);</span><br><span class="line">                % 创建左子树          </span><br><span class="line">                BinTree&#123;2&#125; = createBinTreeNode(&#123;binTreeNode&#123;1&#125;, binTreeNode&#123;2&#125;, binTreeNode&#123;3&#125;, ...</span><br><span class="line">            binTreeNode&#123;4&#125;, binTreeNode&#123;5&#125;, binTreeNode&#123;6&#125;, ubnd&#125;);</span><br><span class="line">            end</span><br><span class="line">        else</span><br><span class="line">            upperBound = min([upperBound; fval]);</span><br><span class="line">            OutputLowerAndUpperBounds();</span><br><span class="line">            result = [result; [x&#x27;, fval]];</span><br><span class="line">            return;</span><br><span class="line">        end</span><br><span class="line">    else</span><br><span class="line">        % 剪枝</span><br><span class="line">        return;</span><br><span class="line">    end  </span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">% IsInRange.m</span><br><span class="line">% 判断分支问题的解是否在上下界的范围中，若不在，剪去</span><br><span class="line">function y = IsInRange(fval)</span><br><span class="line">    global lowerBound;</span><br><span class="line">    global upperBound;</span><br><span class="line"></span><br><span class="line">    if isempty(upperBound) &amp; fval &gt;= lowerBound</span><br><span class="line">        y = 1;</span><br><span class="line">    else if  (fval &gt;= lowerBound &amp; fval &lt;= upperBound)</span><br><span class="line">        y = 1;</span><br><span class="line">    else</span><br><span class="line">        y = 0;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% 打印输出上下界</span><br><span class="line">function y = OutputLowerAndUpperBounds()</span><br><span class="line"></span><br><span class="line">global lowerBound;</span><br><span class="line">global upperBound;</span><br><span class="line"></span><br><span class="line">disp(&#x27;此时下界、上界分别为&#x27;);</span><br><span class="line">disp(lowerBound);</span><br><span class="line">if isempty(upperBound)</span><br><span class="line">    disp(&#x27;  无上界&#x27;)</span><br><span class="line">else</span><br><span class="line">    disp(upperBound);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-割平面法"><a href="#2-割平面法" class="headerlink" title="2.割平面法"></a>2.割平面法</h5><p>1.松弛问题无解，则无解 2.松弛问题最优解为整数，也是最优解 3.割去不包括整数的部分 </p>
<h6 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h6><p>1.用单纯或对偶单纯形法求解（IP）对应的松弛问题（LP）<br>（1）若（LP）没有可行解，则（IP）也没有可行解，停止计算<br>（2）若（LP）有最优解，并符合（IP）的整数条件，则（LP）的最优解即为（IP）的最优解，停止计算。<br>（3）若（LP）有最优解，但不符合（IP）的整数条件，转入下一步<br>2、 从（LP）的最优解中，选取一个和整数差值最大的x，将最优单纯形表中该行的系数分解为整数部分和小数部分，并以该行为源行，作割平面方程<br>3.将所得的割平面方程作为一个新的约束条件置于单纯形表中，用对偶单纯形法求出新的最优解。</p>
<h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line">function [xstar,fxstar,iter] = Gomory(A,b,c)</span><br><span class="line">format rat</span><br><span class="line">%UNTITLED 此处显示有关此函数的摘要</span><br><span class="line">iter=0;%初始化迭代次数</span><br><span class="line">while true</span><br><span class="line">    [m,n]=size(A);%A矩阵大小</span><br><span class="line">    if min(b)&gt;=0</span><br><span class="line">        [x_opt,fx_opt,CA,Cb,~] = Simplex_eye(A,b,c)</span><br><span class="line">    else</span><br><span class="line">        [x_opt,fx_opt,CA,Cb,~] = DSimplex_eye(A,b,c)</span><br><span class="line">    end</span><br><span class="line">    %判断是否已经解出了整数最优解</span><br><span class="line">    flag_zhengshu=1;%flag_zhengshu初始化为1，只要有一个不是整数,flag_zhengshu赋值0</span><br><span class="line">        for pos_x = 1:m</span><br><span class="line">            if abs(round(x_opt(pos_x))-x_opt(pos_x))&gt;=1e-3%判断整数条件</span><br><span class="line">                flag_zhengshu=0;</span><br><span class="line">                break;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        if flag_zhengshu==1%如果解全是整数，满足条件，循环结束</span><br><span class="line">            xstar=x_opt;</span><br><span class="line">            fxstar=fx_opt;</span><br><span class="line">            break;</span><br><span class="line">        end</span><br><span class="line">    iter=iter+1;</span><br><span class="line">    %否则增加约束条件的行</span><br><span class="line">    %找出b中和整数相差最大的数</span><br><span class="line">    %循环遍历</span><br><span class="line">    cha=0;</span><br><span class="line">    row=0;</span><br><span class="line">    for r=1:m</span><br><span class="line">        t=abs(floor(x_opt(r))-x_opt(r));</span><br><span class="line">        if t&gt;cha</span><br><span class="line">            cha=t;</span><br><span class="line">            row=r;%标记当前最大差值的位置</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    n=n+1;</span><br><span class="line">    m=m+1;</span><br><span class="line">    iter=iter+1;</span><br><span class="line">    %更新矩阵系数，在原基础上增加一行一列，第（m,n）=1</span><br><span class="line">    tmp_A=zeros(m,n);</span><br><span class="line">    tmp_b=zeros(m,1);</span><br><span class="line">    tmp_c=zeros(1,n);</span><br><span class="line">    for i=1:m-1</span><br><span class="line">        for j=1:n-1</span><br><span class="line">            tmp_A(i,j)=CA(i,j);</span><br><span class="line">        end</span><br><span class="line">        tmp_b(i,1)=Cb(i,1);</span><br><span class="line">    end</span><br><span class="line">    tmp_A(m,n)=1;</span><br><span class="line">    for i =1:n-1</span><br><span class="line">        tmp_c(1,i)=c(i);</span><br><span class="line">    end</span><br><span class="line">    %加上约束条件</span><br><span class="line">    disp(row);</span><br><span class="line">    for i=1:n-1</span><br><span class="line">        if tmp_A(row,i)==0</span><br><span class="line">            tmp_A(m,i)=0;</span><br><span class="line">        else</span><br><span class="line">            tmp_A(m,i)=floor(tmp_A(row,i))-tmp_A(row,i);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    tmp_b(m,1)=floor(Cb(row,1))-Cb(row,1);</span><br><span class="line">    A=tmp_A;</span><br><span class="line">    b=tmp_b;</span><br><span class="line">    val=[A,b];</span><br><span class="line">    disp(val);</span><br><span class="line">    c=tmp_c;</span><br><span class="line">    disp(c);</span><br><span class="line">end         </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%单纯形法</span><br><span class="line">function [x_opt,fx_opt,CA,Cb,iter] = Simplex_eye(A,b,c)</span><br><span class="line">%x_opt为最优解，fx_opt为最优函数值，iter为迭代次数</span><br><span class="line">iter=0;%初始化迭代次数</span><br><span class="line">[m,n]=size(A);%A矩阵大小</span><br><span class="line">r=nchoosek(1:n,m);%选择排列</span><br><span class="line">I=eye(m,m);%设置一个m阶单位矩阵，用于之后计算的比较和计算</span><br><span class="line">len=length(r);</span><br><span class="line">for i=1:len %从A中寻找一个单位矩阵，也就是基矩阵</span><br><span class="line">    if A(:,[r(i,:)])==I</span><br><span class="line">        bs=r(i,:);</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">s=[1:n];</span><br><span class="line">t=setdiff(s,bs);%setdiff可以计算出s数组中有，而bs数组中没有的元素</span><br><span class="line">flag=0;%flag=1唯一最优解，2无穷多最优解，3有无界解</span><br><span class="line">x=[];%基变量数组</span><br><span class="line">while flag==0 %开始迭代</span><br><span class="line">    iter=iter+1;%迭代次数加1</span><br><span class="line">    x(t)=0;</span><br><span class="line">    x(bs)=b;</span><br><span class="line">    cb=c(bs);</span><br><span class="line">    c_z=zeros(1,n); %计算检验数cj-zj</span><br><span class="line">    for i=1:n</span><br><span class="line">        z=sum(cb&#x27;.*A(:,i));</span><br><span class="line">        c_z(i)=c(:,i)-z;</span><br><span class="line">    end</span><br><span class="line">    %disp(&quot;----------------------第&quot;+iter+&quot;次---------------------------&quot;);</span><br><span class="line">    All=[cb&#x27;,bs&#x27;,b,A];</span><br><span class="line">    %disp(All);</span><br><span class="line">    %disp(c_z);</span><br><span class="line">    if all(c_z &lt;= 0)%最优解</span><br><span class="line">        x_opt=x;</span><br><span class="line">        fx_opt=sum(c.*x_opt);</span><br><span class="line">        if all(c_z(t) &lt; 0)%非基变量都小于0</span><br><span class="line">            flag=1;%唯一最优解</span><br><span class="line">        else</span><br><span class="line">            flag=2;%无穷多最优解</span><br><span class="line">        end</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    [~,n1]=max(c_z);%找到最大的检验数所在位置</span><br><span class="line">   </span><br><span class="line">    if all(A(:,n1) &lt;= 0)%判断无界解,否则继续迭代</span><br><span class="line">        x_opt=[];</span><br><span class="line">        flag=3;</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line">    b1 = b./ A(:,n1);</span><br><span class="line">    b1(b1&lt;=0)=inf;%将小于等于0的数设为无穷大，</span><br><span class="line">    [~,m1]=min(b1);%选出非负中的最小值对应的变量换出</span><br><span class="line">    bs(m1)=n1;%n1对应为换入变量，m1对应换出变量</span><br><span class="line">    t=setdiff(s,bs);</span><br><span class="line">    A(:,t) = inv(A(:,bs))*A(:,t); %基矩阵的逆乘以非基矩阵</span><br><span class="line">    b = inv(A(:,bs))*b;  %基矩阵的逆乘以b</span><br><span class="line">    A(:,bs) = I;  %基矩阵更新为单位矩阵</span><br><span class="line">end</span><br><span class="line">if flag==1</span><br><span class="line">    disp(&#x27;唯一最优解&#x27;);</span><br><span class="line">    CA=A;</span><br><span class="line">    Cb=b;</span><br><span class="line">    return</span><br><span class="line">elseif flag==2</span><br><span class="line">    disp(&#x27;无穷多最优解&#x27;);</span><br><span class="line">    return</span><br><span class="line">elseif flag==3</span><br><span class="line">    disp(&#x27;有无界解&#x27;);</span><br><span class="line">    fx_opt=inf;</span><br><span class="line">    return</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%对偶单纯形法</span><br><span class="line">function [x_opt,fx_opt,CA,Cb,iter] = DSimplex_eye(A,b,c)</span><br><span class="line">% 输入参数: c为目标函数系数, A为约束方程组系数矩阵, b为约束方程组常数项</span><br><span class="line">% 输出参数: x_opt最优解, fx_opt最优目标函数值, iter迭代次数</span><br><span class="line"></span><br><span class="line">iter=0;%初始化迭代次数</span><br><span class="line">[m,n]=size(A);%A矩阵大小</span><br><span class="line">r=nchoosek(1:n,m);%选择排列</span><br><span class="line">I=eye(m,m);%设置一个m阶单位矩阵，用于之后计算的比较和计算</span><br><span class="line">len=length(r);</span><br><span class="line">for i=1:len %从A中寻找一个单位矩阵，也就是基矩阵</span><br><span class="line">    flag=is_ones(A(:,[r(i,:)]));%判断是否单位矩阵</span><br><span class="line">    if flag==1</span><br><span class="line">        disp(A(:,[r(i,:)]));</span><br><span class="line">        disp(&#x27;找到&#x27;);</span><br><span class="line">        bs=r(i,:);</span><br><span class="line">        break;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">s=[1:n];</span><br><span class="line">ind_N=setdiff(s,bs);</span><br><span class="line"></span><br><span class="line">x=[];%基变量数组</span><br><span class="line">while true         % 迭代</span><br><span class="line">    x(ind_N)=0;</span><br><span class="line">    x(bs) = b;</span><br><span class="line">    cB = c(bs);                %计算cB</span><br><span class="line">    Sigma = zeros(1,n); %检验数数组</span><br><span class="line">    for i=1:n</span><br><span class="line">        z=sum(cB&#x27;.*A(:,i));</span><br><span class="line">        Sigma(i)=c(:,i)-z;</span><br><span class="line">    end</span><br><span class="line">    [~,q] = min(b);               %选出最小的b，换出</span><br><span class="line">    r = bs(q);        </span><br><span class="line">    Theta = Sigma ./ A(q,:);      %计算θ</span><br><span class="line">    Theta(Theta&lt;=0) = inf;</span><br><span class="line">    [~,s] = min(Theta);         %确定进基变量索引s, 主元为A(q,s)</span><br><span class="line">    vals = [cB&#x27;,bs&#x27;,b,A];</span><br><span class="line">    vals = [vals; NaN, NaN, NaN, Sigma];</span><br><span class="line">    %disp(&quot;-----------------------第&quot;+iter+&quot;次--------------------------&quot;)</span><br><span class="line">    %disp(vals);</span><br><span class="line">    if all(b &gt;= 0)         %最优解       </span><br><span class="line">        x_opt = x;</span><br><span class="line">        fx_opt = sum(c .* x_opt);</span><br><span class="line">        CA=A;</span><br><span class="line">        Cb=b;</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    iter=iter+1;</span><br><span class="line">    % 换基</span><br><span class="line">    bs(bs == r) = s;      %新的基变量索引</span><br><span class="line">    ind_N = setdiff(1:n, bs); %非基变量索引</span><br><span class="line">    % 更新A和b</span><br><span class="line">    A(:,ind_N) = inv(A(:,bs))* A(:,ind_N);</span><br><span class="line">    b = inv(A(:,bs))* b;</span><br><span class="line">    A(:,bs) = I;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function [flag]=is_ones(a)%判断矩阵是否为单位阵</span><br><span class="line">    flag=1;</span><br><span class="line">    [row_a,col_a]=size(a);</span><br><span class="line">    tmp_a=zeros(row_a);%对应的列只有一个1,其他全是0，否则flag=flase;</span><br><span class="line">    for i1 =1:row_a</span><br><span class="line">        for j1 = 1:col_a</span><br><span class="line">            if a(i1,j1)==1 &amp;&amp; tmp_a(j1)==0</span><br><span class="line">                tmp_a(j1)=1;</span><br><span class="line">            elseif a(i1,j1)==0</span><br><span class="line">                continue;</span><br><span class="line">            else</span><br><span class="line">                flag=0;</span><br><span class="line">                break;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    for i1 =1:row_a</span><br><span class="line">        if tmp_a(i1)==0</span><br><span class="line">            flag=0;</span><br><span class="line">            break;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=[-1 3 1 0;7 1 0 1];</span><br><span class="line">b=[6 35]&#x27;;</span><br><span class="line">c=[7 9 0 0];</span><br><span class="line">[xstar,fxstar,iter] = Gomory(A,b,c)</span><br></pre></td></tr></table></figure>

<h3 id="matlab"><a href="#matlab" class="headerlink" title="matlab:"></a>matlab:</h3><p>intlinprog是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=matlab&spm=1001.2101.3001.7020">matlab</a>中用于求解混合整数线性规划的一个函数</p>
<p>例1：求解下列整数规划。</p>
<p><img src="https://img-blog.csdnimg.cn/20210715104914558.png" alt="img"></p>
<p>解：求解的matlab程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c=[2;3;4];</span><br><span class="line">a=[1.5,3,5;280,250,400];</span><br><span class="line">b=[600;60000];</span><br><span class="line">intcon=[1,2,3];//整数所在位置</span><br><span class="line">[x,y]=intlinprog(-c,intcon,a,b,[],[],zeros(3,1))</span><br><span class="line">x,y=-y</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210715105316521.png" alt="img"></p>
<p>求得当x1&#x3D;64，x2&#x3D;168，x3&#x3D;0时，最大值y&#x3D;632。</p>
<p><strong>intcon ：整数所在位置</strong></p>
<h2 id="三、0-1整数线性规划"><a href="#三、0-1整数线性规划" class="headerlink" title="三、0-1整数线性规划"></a>三、0-1整数线性规划</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>决策变量x仅取值0或1的整数规划。</p>
<h3 id="2-一般形式-1"><a href="#2-一般形式-1" class="headerlink" title="2.一般形式"></a>2.一般形式</h3><p><img src="C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220806215816855.png" alt="image-20220806215816855"></p>
<h3 id="3-步骤-1"><a href="#3-步骤-1" class="headerlink" title="3.步骤"></a>3.步骤</h3><p>采用隐枚举法；列出所有可能决策变量组合的值</p>
<p>1、只要发现某个变量组合不满足其中一个约束条件时，就不必再去检验其他约束条件是否可行。</p>
<p>2、若已发现一个可行解，则可根据它的目标函数值产生一个过滤条件，对于目标函数值比它差的变量组合就不必再去检验它的可行性；在以后的求解中，每当发现更好的可行解，则以此替换原来的过滤条件。</p>
<h3 id="4-指派问题"><a href="#4-指派问题" class="headerlink" title="4.指派问题"></a>4.指派问题</h3><p>指派问题：有n项不同的任务，需要n个人分别完成其中的一项，由于各人去完成不同的任务所花费的时间（或费用)不同。于是产生了一个问题，应指派哪个人去完成哪项任务，使完成n项任务的所需时间最少。</p>
<p>匈牙利算法</p>
<p>1.核心思想</p>
<p>若从指派问题的系数矩阵C的某行（或某列）各元素分别减去一个常数k，得到一个新的矩阵C’，则以C’和C为系数矩阵的两个指派问题有相同的最优解。这是由于系数矩阵的变化并不影响数学模型的约束方程组，只是目标函数值减少了常数k，所以最优解不变。</p>
<ol start="2">
<li>匈牙利解法步骤</li>
</ol>
<p>​	1、变换系数矩阵，先对各行元素分别减去本行中的最小元素，再对各列元素分别减去本列最小元素，从而保证系数矩阵中每行及每列中至少有一个零元素。</p>
<p>​	2、在变换后的系数矩阵中确定独立零元素。若独立零元素有n个，则已得出最优解；若独立零元素少于n个，则做能覆盖所有零元素的最少直线数目的直线集合。</p>
<p>（1）对没有⚪的行打√号；</p>
<p>（2）对已打√号的行中所有被划去0元素的所在列打√号；</p>
<p>（3）再对打有√号的列中⚪中0元素的所在行打√号；</p>
<p>（4）重复(2)(3)，直到得不出新的打√号的行(列)为止；</p>
<p>（5）对没有打√号的行画横线，对打√号的列画一纵线，这就得到覆盖所有0元素的最少直线数目的直线集合。</p>
<p>​	3、继续变换系数矩阵，在未被直线覆盖的元素中找出一个最小元素，对未被覆盖的元素所在行（或列）中各元素都减去这一最小元素。对出现负元素的行或列都加上这一最小元素。返回步骤2。</p>
<p>匈牙利算法代码：</p>
<p>Hungary.m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function res=Hungary(N)</span><br><span class="line">%输入的矩阵应N*N的</span><br><span class="line">[a,~]=size(N);</span><br><span class="line">%第一步每一行减去当前行最小值</span><br><span class="line">for ii = 1:a</span><br><span class="line">    N(ii,:)= N(ii,:)-min( N(ii,:));</span><br><span class="line">end</span><br><span class="line">%第二步每一列减去当前列最小值</span><br><span class="line">for ii = 1:a</span><br><span class="line">    N(:,ii)=  N(:,ii)-min( N(:,ii));</span><br><span class="line">end</span><br><span class="line">num=0;</span><br><span class="line">while num~=a</span><br><span class="line">    [num,N_min,del_hang,del_lie]=line_count(N);</span><br><span class="line">    if num ~=a</span><br><span class="line">        for ii=1:a</span><br><span class="line">            if del_hang(ii)~=ii</span><br><span class="line">                N(ii,:) =  N(ii,:)-N_min;</span><br><span class="line">            end</span><br><span class="line">            if del_lie(ii)==ii</span><br><span class="line">            N(:,ii) =  N(:,ii)+N_min;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    else</span><br><span class="line">        res=N;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>line_count.m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function [num,M_min,del_hang,del_lie]=line_count(M)</span><br><span class="line">[a,~]=size(M);</span><br><span class="line">num=0;</span><br><span class="line">h=0;</span><br><span class="line">del_hang=zeros(a,1);</span><br><span class="line">del_lie=zeros(a,1);</span><br><span class="line">for ii=1:a</span><br><span class="line">    del=ii-h;</span><br><span class="line">    [~,b]=size(find(M(del,:)==0));</span><br><span class="line">    if   b&gt;= 2</span><br><span class="line">        M(del,:)=[];</span><br><span class="line">        h=h+1;</span><br><span class="line">        del_hang(ii)=ii;    %得到被覆盖的行数</span><br><span class="line">        num=num+1;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">l=0;</span><br><span class="line">for ii=1:a</span><br><span class="line">    del=ii-l;</span><br><span class="line">    [b,~]=size(find(M(:,del)==0));</span><br><span class="line">    if  b &gt;=1</span><br><span class="line">        M(:,del)=[];</span><br><span class="line">        l=l+1;</span><br><span class="line">        del_lie(ii)=ii;    %得到被覆盖的列数</span><br><span class="line">        num=num+1;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">M_min=min(min(M));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>linear_assignment.m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">function [place,res]=linear_assignment(M,N)</span><br><span class="line">%N是n维矩阵,N是经过Hungary处理的</span><br><span class="line">%M是未处理前的</span><br><span class="line">[a,~]=size(N);</span><br><span class="line">x=0;</span><br><span class="line">place=zeros(1,a);</span><br><span class="line">res=zeros(1,a);</span><br><span class="line">judge=zeros(1,a);</span><br><span class="line">while find(N==0)</span><br><span class="line">    for ii=1:a</span><br><span class="line">    judge(ii)=length(find(N(ii,:)==0));</span><br><span class="line">    end</span><br><span class="line">    judge(find(judge==0))=[];</span><br><span class="line">    if min(judge)==1</span><br><span class="line">     for ii=1:a</span><br><span class="line">        if length(find(N(ii,:)==0))==1     %先选出行中只有1个0</span><br><span class="line">            x=x+1;</span><br><span class="line">            place(x)=ii+(find(N(ii,:)==0)-1)*a; %得到矩阵中的位置</span><br><span class="line">            h=find(N(ii,:)==0);</span><br><span class="line">            N(ii,:)=1./zeros(1,a);</span><br><span class="line">            N(:,h)=1./zeros(a,1);</span><br><span class="line">        end</span><br><span class="line">     end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    for ii=1:a</span><br><span class="line">    judge(ii)=length(find(N(ii,:)==0));</span><br><span class="line">    end</span><br><span class="line">    judge(find(judge==0))=[];</span><br><span class="line">    </span><br><span class="line">    if min(judge)==2</span><br><span class="line">       x=x+1;</span><br><span class="line">    q=find(N==0);</span><br><span class="line">    place(x)=q(1);</span><br><span class="line">    N(mod(q(1),a),:)=1./zeros(1,a);</span><br><span class="line">    N(:,fix(q(1)/a)+1)=1./zeros(a,1);  </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">[place,~]=sort(place);</span><br><span class="line">for ii=1:length(place)</span><br><span class="line">    res(ii)=M(place(ii));</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5.代码"></a>5.代码</h3><p>matlab中用于求解混合整数线性规划的一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,fval,exitflag]= intlinprog(f,intcon,A,b,Aeq,beq,lb,ub)</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210217210139890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dheW5lNjUxNQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">clc,clear,close all</span><br><span class="line">f = [15 18 21 24 19 23 22 18 26 17 16 19 19 21 23 17];</span><br><span class="line">ic = [1:16];</span><br><span class="line">Aeq = [ones(1,4),zeros(1,12);...</span><br><span class="line">    zeros(1,4),ones(1,4),zeros(1,8);...</span><br><span class="line">    zeros(1,8),ones(1,4),zeros(1,4);...</span><br><span class="line">    zeros(1,12),ones(1,4);...</span><br><span class="line">    [1,zeros(1,3),1,zeros(1,3),1,zeros(1,3),1,zeros(1,3)];...</span><br><span class="line">    [0,1,zeros(1,3),1,zeros(1,3),1,zeros(1,3),1,zeros(1,2)];...</span><br><span class="line">    [zeros(1,2),1,zeros(1,3),1,zeros(1,3),1,zeros(1,3),1,0];...</span><br><span class="line">    [zeros(1,3),1,zeros(1,3),1,zeros(1,3),1,zeros(1,3),1]];</span><br><span class="line">beq = ones(8,1);</span><br><span class="line">lb = zeros(16,1);		</span><br><span class="line">ub = ones(16,1);//下限是0，上限是1，同时限制了变量是整数		</span><br><span class="line">[x,fval] = intlinprog(f,ic,[],[],Aeq,beq,lb,ub)	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四、非线性规划"><a href="#四、非线性规划" class="headerlink" title="四、非线性规划"></a>四、非线性规划</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题</p>
<h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h3><h4 id="有约束非线性规划"><a href="#有约束非线性规划" class="headerlink" title="有约束非线性规划"></a>有约束非线性规划</h4><h4 id="1-一般形式"><a href="#1-一般形式" class="headerlink" title="1.一般形式"></a>1.一般形式</h4><p><img src="https://img-blog.csdnimg.cn/2021053017280132.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210530172825134.png" alt="img"></p>
<h4 id="2-matlab代码"><a href="#2-matlab代码" class="headerlink" title="2.matlab代码"></a>2.matlab代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=FMINCON(FUN,X0,A,B,Aeq,Beq,LB,UB,NONLCON,OPTIONS)</span><br></pre></td></tr></table></figure>

<p>返回值是向量 x ，其中 FUN 是用 M 文件定义的函数 f (x)；X0 是 x 的初始值；A,B,Aeq,Beq 定义了线性约束 A* X ≤ B, Aeq * X &#x3D; Beq ，如果没有线性约束，则A&#x3D;[],B&#x3D;[],Aeq&#x3D;[],Beq&#x3D;[]；如果 x 无下界，则 LB 的各分量都为-inf，如果 x 无上界，则 UB的各分量都为 inf；NONLCON 是用 M 文件定义的非线性向量函数C(x),Ceq(x) ；OPTIONS定义了优化参数，可以使用 Matlab 缺省的参数设置。<br>例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210530172837714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTI4Mjgz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>定义目标函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f=fun1(x);</span><br><span class="line">f=sum(x.^2)+8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义非线性约束函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function [g,h]=fun2(x); </span><br><span class="line">g=[-x(1)^2+x(2)-x(3)^2 </span><br><span class="line">x(1)+x(2)^2+x(3)^3-20]; %非线性不等式约束</span><br><span class="line">h=[-x(1)-x(2)^2+2 </span><br><span class="line">x(2)+2*x(3)^2-3]; %非线性等式约束</span><br></pre></td></tr></table></figure>

<p>主程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options=optimset(&#x27;largescale&#x27;,&#x27;off&#x27;);  [x,y]=fmincon(&#x27;fun1&#x27;,rand(3,1),[],[],[],[],zeros(3,1),[], ...  &#x27;fun2&#x27;, options) </span><br></pre></td></tr></table></figure>

<h4 id="无约束线性规划"><a href="#无约束线性规划" class="headerlink" title="无约束线性规划"></a>无约束线性规划</h4><p>matlab代码</p>
<p> <strong>fminunc函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,fval, exitflag, output, lambda, grad, hessian]= fminunc(‘fun’, x0, options)</span><br></pre></td></tr></table></figure>

<p> <strong>fminsearch函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,fval, exitflag, output] = fminbnd(‘fun’, x0, options)</span><br></pre></td></tr></table></figure>

<h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p>二次规划</p>
<p>若某非线性规划的目标函数为自变量 x 的二次函数，约束条件又全是线性的，就称这种规划为二次规划。</p>
<p>matlab命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[X,FVAL]= QUADPROG(H,f,A,b,Aeq,beq,LB,UB,X0,OPTIONS)</span><br></pre></td></tr></table></figure>

<p>凸规划</p>
<p>目标函数是定义在凸集上的凸函数</p>
<p>性质：凸规划的可行域为凸集，其局部最优解即为全局最优解，而且其最优解的集合形成一个凸集。当凸规划的目标函数 f (x)为严格凸函数时，其最优解必定唯一（假定最优解存在）。</p>
<h2 id="五、目标规划"><a href="#五、目标规划" class="headerlink" title="五、目标规划"></a>五、目标规划</h2><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h3><p>目标规划是一种用来进行含有单目标和多目标的决策分析的数学规划方法。线性规划的一种特殊类型（含有多个目标函数）。</p>
<p>1、正、负偏差变量</p>
<p><a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/657755/201502/050225384064005.png"><img src="https://images0.cnblogs.com/blog/657755/201502/050225437813681.png" alt="image"></a></p>
<p>2、绝对约束和目标约束</p>
<p>（1）绝对约束：一定要达到的要求，线性规划的约束条件都是</p>
<p>（2）软约束（目标约束）：就是在这个目标值允许有一定的正负偏差存在。</p>
<p>3、优先因子（优先等级）与权系数</p>
<p>   一个规划问题如果有多个目标，可以按照重要性来规定一个优先因子P，越重要的越优先。</p>
<p>4、目标规划的目标函数</p>
<p>   每一个目标值确定后，要求是尽可能小的缩小偏差。因此目标函数只能是<a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/657755/201502/050225446249039.png"><img src="https://images0.cnblogs.com/blog/657755/201502/050225454533927.png" alt="image"></a>，有三种形式</p>
<p>（1）要求恰好达到目标值，即正负偏差都要小</p>
<p>​        <a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/657755/201502/050225462182327.png"><img src="https://images0.cnblogs.com/blog/657755/201502/050225466715398.png" alt="image"></a></p>
<p>（2）要求不超过目标值，正偏差小</p>
<p>​       <a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/657755/201502/050225471713485.png"><img src="https://images0.cnblogs.com/blog/657755/201502/050225479215114.png" alt="image"></a></p>
<p>（3）要求超过目标值，负偏差小</p>
<p>​        <a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/657755/201502/050225483748185.png"><img src="https://images0.cnblogs.com/blog/657755/201502/050225492653857.png" alt="image"></a></p>
<p>5、目标规划的一般数学模型</p>
<p><a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/657755/201502/050225541713690.png"><img src="https://images0.cnblogs.com/blog/657755/201502/050226014535681.png" alt="image"></a></p>
<h3 id="2-matlab命令"><a href="#2-matlab命令" class="headerlink" title="2.matlab命令"></a>2.matlab命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fgoalattain(fun,x0,goal,weight,A,b,Aeq,beq,lb,ub,nonlcon,options)</span><br></pre></td></tr></table></figure>

<p>fun目标函数</p>
<p>goal：需要实现的目标；<strong>数值目标（goal）是≤的时候，系数为+</strong></p>
<p>weight权重</p>
<h2 id="六、动态规划"><a href="#六、动态规划" class="headerlink" title="六、动态规划"></a>六、动态规划</h2><h3 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h3><p>求解决策过程最优化的数学方法。（递归）</p>
<p>基本思想</p>
<p>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/07/%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/" data-id="cl7rno6ab00009gvk8mrmhaq2" data-title="规划模型" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/09/07/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/07/%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/">规划模型</a>
          </li>
        
          <li>
            <a href="/2022/09/07/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>